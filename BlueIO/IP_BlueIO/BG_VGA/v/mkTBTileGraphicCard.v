//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Wed Nov 16 14:38:29 GMT 2016
//
// Method conflict info:
// (none)
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkTBTileGraphicCard(CLK,
			   RST_N);
  input  CLK;
  input  RST_N;

  // register counter_reg
  reg [31 : 0] counter_reg;
  wire [31 : 0] counter_reg$D_IN;
  wire counter_reg$EN;

  // ports of submodule gc
  reg [31 : 0] gc$bluetile_response_put;
  wire [31 : 0] gc$bluetile_request_get;
  wire gc$EN_bluetile_request_get,
       gc$EN_bluetile_response_put,
       gc$RDY_bluetile_request_get,
       gc$RDY_bluetile_response_put;

  // rule scheduling signals
  wire CAN_FIRE_RL_display,
       CAN_FIRE_RL_testbench_counter,
       CAN_FIRE_RL_testbench_putval,
       CAN_FIRE_RL_testbench_putval_2,
       CAN_FIRE_RL_testbench_putval_3,
       CAN_FIRE_RL_testbench_putval_4,
       CAN_FIRE_RL_testbench_putval_5,
       CAN_FIRE_RL_testbench_putval_6,
       WILL_FIRE_RL_display,
       WILL_FIRE_RL_testbench_counter,
       WILL_FIRE_RL_testbench_putval,
       WILL_FIRE_RL_testbench_putval_2,
       WILL_FIRE_RL_testbench_putval_3,
       WILL_FIRE_RL_testbench_putval_4,
       WILL_FIRE_RL_testbench_putval_5,
       WILL_FIRE_RL_testbench_putval_6;

  // inputs to muxes for submodule ports
  wire MUX_gc$bluetile_response_put_1__SEL_4;

  // submodule gc
  mkTileGraphicCard gc(.CLK(CLK),
		       .RST_N(RST_N),
		       .bluetile_response_put(gc$bluetile_response_put),
		       .EN_bluetile_request_get(gc$EN_bluetile_request_get),
		       .EN_bluetile_response_put(gc$EN_bluetile_response_put),
		       .vga_pins_hsync(),
		       .vga_pins_vsync(),
		       .vga_pins_vga_red(),
		       .vga_pins_vga_green(),
		       .vga_pins_vga_blue(),
		       .bluetile_request_get(gc$bluetile_request_get),
		       .RDY_bluetile_request_get(gc$RDY_bluetile_request_get),
		       .RDY_bluetile_response_put(gc$RDY_bluetile_response_put));

  // rule RL_testbench_putval
  assign CAN_FIRE_RL_testbench_putval =
	     gc$RDY_bluetile_response_put && counter_reg == 32'd10 ;
  assign WILL_FIRE_RL_testbench_putval = CAN_FIRE_RL_testbench_putval ;

  // rule RL_testbench_putval_2
  assign CAN_FIRE_RL_testbench_putval_2 =
	     gc$RDY_bluetile_response_put && counter_reg == 32'd11 ;
  assign WILL_FIRE_RL_testbench_putval_2 = CAN_FIRE_RL_testbench_putval_2 ;

  // rule RL_testbench_putval_3
  assign CAN_FIRE_RL_testbench_putval_3 =
	     gc$RDY_bluetile_response_put && counter_reg == 32'd12 ;
  assign WILL_FIRE_RL_testbench_putval_3 = CAN_FIRE_RL_testbench_putval_3 ;

  // rule RL_testbench_putval_4
  assign CAN_FIRE_RL_testbench_putval_4 =
	     gc$RDY_bluetile_response_put && counter_reg == 32'd13 ;
  assign WILL_FIRE_RL_testbench_putval_4 = CAN_FIRE_RL_testbench_putval_4 ;

  // rule RL_testbench_putval_5
  assign CAN_FIRE_RL_testbench_putval_5 =
	     gc$RDY_bluetile_response_put && counter_reg == 32'd14 ;
  assign WILL_FIRE_RL_testbench_putval_5 = CAN_FIRE_RL_testbench_putval_5 ;

  // rule RL_testbench_putval_6
  assign CAN_FIRE_RL_testbench_putval_6 =
	     gc$RDY_bluetile_response_put && counter_reg == 32'd15 ;
  assign WILL_FIRE_RL_testbench_putval_6 = CAN_FIRE_RL_testbench_putval_6 ;

  // rule RL_testbench_counter
  assign CAN_FIRE_RL_testbench_counter = 1'd1 ;
  assign WILL_FIRE_RL_testbench_counter = 1'd1 ;

  // rule RL_display
  assign CAN_FIRE_RL_display = gc$RDY_bluetile_request_get ;
  assign WILL_FIRE_RL_display = gc$RDY_bluetile_request_get ;

  // inputs to muxes for submodule ports
  assign MUX_gc$bluetile_response_put_1__SEL_4 =
	     WILL_FIRE_RL_testbench_putval_4 ||
	     WILL_FIRE_RL_testbench_putval ;

  // register counter_reg
  assign counter_reg$D_IN = counter_reg + 32'd1 ;
  assign counter_reg$EN = 1'd1 ;

  // submodule gc
  always@(WILL_FIRE_RL_testbench_putval_2 or
	  WILL_FIRE_RL_testbench_putval_3 or
	  WILL_FIRE_RL_testbench_putval_5 or
	  MUX_gc$bluetile_response_put_1__SEL_4 or
	  WILL_FIRE_RL_testbench_putval_6)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_testbench_putval_2:
	  gc$bluetile_response_put = 32'h00002B2B;
      WILL_FIRE_RL_testbench_putval_3:
	  gc$bluetile_response_put = 32'h00F0100B;
      WILL_FIRE_RL_testbench_putval_5:
	  gc$bluetile_response_put = 32'h01012B2B;
      MUX_gc$bluetile_response_put_1__SEL_4:
	  gc$bluetile_response_put = 32'h02000002;
      WILL_FIRE_RL_testbench_putval_6:
	  gc$bluetile_response_put = 32'h02F2802B;
      default: gc$bluetile_response_put =
		   32'hAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign gc$EN_bluetile_request_get = gc$RDY_bluetile_request_get ;
  assign gc$EN_bluetile_response_put =
	     WILL_FIRE_RL_testbench_putval_2 ||
	     WILL_FIRE_RL_testbench_putval_3 ||
	     WILL_FIRE_RL_testbench_putval_5 ||
	     WILL_FIRE_RL_testbench_putval_4 ||
	     WILL_FIRE_RL_testbench_putval ||
	     WILL_FIRE_RL_testbench_putval_6 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        counter_reg <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (counter_reg$EN)
	  counter_reg <= `BSV_ASSIGNMENT_DELAY counter_reg$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    counter_reg = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N)
      if (gc$RDY_bluetile_request_get) $display(gc$bluetile_request_get);
  end
  // synopsys translate_on
endmodule  // mkTBTileGraphicCard

